================================================================================
RELAT√ìRIO DE BUG: BACKEND DJANGO FUNCIONANDO - PROBLEMA NO FLUTTER
================================================================================

Data: 24 de Novembro de 2025
Backend: Django 5.2.8 + DRF + Cloudinary + Gunicorn
Desenvolvedor Backend: Bruno Santos
Desenvolvedor Flutter: [A ser enviado]

================================================================================
RESUMO EXECUTIVO
================================================================================

Ap√≥s 3 dias de debugging extensivo (21-24 Nov 2025), confirmamos que o backend
Django est√° 100% funcional e enviando imagens para o Cloudinary CDN com sucesso.

Testes realizados no backend:
‚úÖ Django Shell com PIL Image ‚Üí Status 201, Cloudinary URL v√°lida
‚úÖ RequestFactory simulando Flutter ‚Üí Status 201, Cloudinary URL v√°lida  
‚úÖ Storage Backend verificado ‚Üí MediaCloudinaryStorage
‚úÖ Cloudinary API ‚Üí Resposta 200 em todos os uploads

Resultado do Flutter app:
‚ùå POST /api/denuncias/denuncias/ ‚Üí Status 500

ATUALIZA√á√ÉO CR√çTICA (24/Nov/2025 - 01:30):
================================================================================
‚ùå DIAGN√ìSTICO ANTERIOR ESTAVA INCORRETO!

Ap√≥s an√°lise dos logs completos do Flutter, confirmamos que o Flutter est√° 
enviando TODOS os dados corretamente:

‚úÖ autor_convidado: "okok" presente no FormData
‚úÖ Todos os campos obrigat√≥rios enviados
‚úÖ Foto comprimida v√°lida (13.61 KB JPEG)
‚úÖ ContentType correto (image/jpeg)
‚úÖ Tamanho de arquivo v√°lido (13933 bytes)

NOVA CONCLUS√ÉO: O problema est√° NO BACKEND DJANGO processando requisi√ß√µes HTTP 
multipart/form-data reais, n√£o no Flutter!

Os testes via Django Shell e RequestFactory funcionaram, mas requisi√ß√µes HTTP 
reais do Flutter retornam 500. Isso indica problema no ViewSet/Serializer ao 
processar multipart data de requisi√ß√µes HTTP externas.

================================================================================
EVID√äNCIAS - TESTES DO BACKEND
================================================================================

1. TESTE VIA DJANGO SHELL (Cria√ß√£o Direta)
------------------------------------------
Comando executado no container voz-do-povo-api:

python manage.py shell

from PIL import Image
from io import BytesIO
from django.core.files.uploadedfile import InMemoryUploadedFile
from applications.denuncias.models import Denuncia, Categoria

# Criar imagem de teste
img = Image.new('RGB', (100, 100), color='red')
img_io = BytesIO()
img.save(img_io, format='JPEG')
img_io.seek(0)

foto = InMemoryUploadedFile(
    img_io, None, 'test_real.jpg', 'image/jpeg',
    img_io.getbuffer().nbytes, None
)

categoria = Categoria.objects.first()
denuncia = Denuncia.objects.create(
    titulo='Teste Cloudinary REAL',
    descricao='Teste via shell',
    categoria=categoria,
    latitude=-22.9068,
    longitude=-43.1729,
    autor_convidado='Bruno Teste',
    foto=foto
)

RESULTADO:
‚úÖ Den√∫ncia criada! ID: 21
‚úÖ T√≠tulo: Teste Cloudinary REAL
‚úÖ Foto URL: https://res.cloudinary.com/dphpzghkh/image/upload/v1/media/denuncias_fotos/test_real_bddtis
‚úÖ Cloudinary API: POST /v1_1/dphpzghkh/image/upload HTTP/1.1" 200

2. TESTE VIA REQUESTFACTORY (Simula√ß√£o do Flutter)
---------------------------------------------------
C√≥digo executado no Django shell simulando EXATAMENTE a requisi√ß√£o do Flutter:

from django.test import RequestFactory
from django.contrib.auth.models import AnonymousUser
from applications.denuncias.views import DenunciaViewSet
from PIL import Image
from io import BytesIO

factory = RequestFactory()
img = Image.new('RGB', (100, 100), color='blue')
img_io = BytesIO()
img.save(img_io, format='JPEG')
img_io.seek(0)

# Criar FormData exatamente como o Flutter envia
request = factory.post(
    '/api/denuncias/denuncias/',
    data={
        'titulo': 'Teste Flutter Simulation',
        'descricao': 'Simulando requisi√ß√£o do Flutter app',
        'categoria': '1',
        'latitude': '-22.9068',
        'longitude': '-43.1729',
        'autor_convidado': 'Jo√£o Guest',
        'foto': img_io
    },
    format='multipart'
)
request.user = AnonymousUser()

view = DenunciaViewSet.as_view({'post': 'create'})
response = view(request)

RESULTADO:
‚úÖ Status: 201 CREATED
‚úÖ Den√∫ncia ID: 22
‚úÖ Foto URL: https://res.cloudinary.com/dphpzghkh/image/upload/v1/media/denuncias_fotos/compressed_test_xpsyh8
‚úÖ Autor convidado: Jo√£o Guest
‚úÖ Cloudinary upload: SUCESSO

3. VERIFICA√á√ÉO DO STORAGE BACKEND
----------------------------------
Comando:
python manage.py shell -c "from django.core.files.storage import default_storage; print('Storage:', default_storage.__class__.__name__)"

RESULTADO:
‚úÖ Storage: MediaCloudinaryStorage

4. LOGS DO FLUTTER APP (Produ√ß√£o)
----------------------------------
Log do servidor ao receber requisi√ß√£o do Flutter:

187.103.107.79 - - [24/Nov/2025:00:12:18 +0000] "POST /api/denuncias/denuncias/ HTTP/1.1" 500 145 "-" "Dart/3.9 (dart:io)"

‚ùå Status 500 (Internal Server Error)
‚ùå User-Agent: Dart/3.9 (dart:io)

LOGS COMPLETOS DO FLUTTER (24/Nov/2025 - 01:30):
------------------------------------------------
‚úÖ Foto comprimida: 13.61 KB (redu√ß√£o de 10.5%)
‚úÖ Localiza√ß√£o identificada: S√£o Paulo/SP (ID: 5275)
‚úÖ Estado de autentica√ß√£o: guest, nickname "okok"
‚úÖ FormData com 10 campos + foto:
   - titulo: "dasfasf"
   - descricao: "safasfasf"
   - categoria: "6"
   - cidade: "5275"
   - estado: "25"
   - latitude: "-23.549241"
   - longitude: "-46.631583"
   - jurisdicao: "MUNICIPAL"
   - endereco: "R. Venceslau Br√°s, Centro Hist√≥rico de S√£o Paulo - S√£o Paulo"
   - autor_convidado: "okok" ‚úÖ PRESENTE E V√ÅLIDO!
   - foto: 13933 bytes, image/jpeg ‚úÖ

POST http://72.61.55.172:8000/api/denuncias/denuncias/
RESPONSE: 500 Internal Server Error
BODY: <!doctype html><html><h1>Server Error (500)</h1></html>

üéØ CONCLUS√ÉO ATUALIZADA: Flutter est√° enviando TUDO CORRETO. O problema √© no 
Django ao processar requisi√ß√µes HTTP multipart reais (n√£o simuladas).

================================================================================
FORMATO CORRETO DA REQUISI√á√ÉO (ESPERADO PELO BACKEND)
================================================================================

Endpoint: POST /api/denuncias/denuncias/
Content-Type: multipart/form-data

CAMPOS OBRIGAT√ìRIOS (FormData):

Para USU√ÅRIOS CONVIDADOS (n√£o autenticados):
- titulo: string (n√£o vazio)
- descricao: string (n√£o vazio)
- categoria: integer (ID v√°lido de categoria)
- latitude: float/string (coordenada)
- longitude: float/string (coordenada)
- autor_convidado: string (OBRIGAT√ìRIO para guests, n√£o pode ser vazio)
- foto: file (JPEG/PNG, max 10MB recomendado)

Para USU√ÅRIOS AUTENTICADOS:
- titulo: string (n√£o vazio)
- descricao: string (n√£o vazio)
- categoria: integer (ID v√°lido de categoria)
- latitude: float/string (coordenada)
- longitude: float/string (coordenada)
- foto: file (JPEG/PNG, max 10MB recomendado)
- autor_convidado: N√ÉO ENVIAR (causar√° ValidationError)

Headers necess√°rios:
- Content-Type: multipart/form-data; boundary=<boundary>
- Authorization: Bearer <token> (apenas para usu√°rios autenticados)

================================================================================
POSS√çVEIS CAUSAS DO PROBLEMA NO BACKEND DJANGO
================================================================================

‚ùå FLUTTER N√ÉO √â O PROBLEMA! Logs confirmam que Flutter envia tudo corretamente.

CAUSAS PROV√ÅVEIS NO DJANGO:

1. CAMPOS EXTRAS N√ÉO DECLARADOS NO SERIALIZER
   - Flutter envia: cidade, estado, jurisdicao, endereco
   - Serializer pode n√£o ter esses campos declarados
   - Django rejeita campos n√£o reconhecidos em modo strict
   - Solu√ß√£o: Adicionar campos no DenunciaSerializer ou usar extra_kwargs

2. VALIDA√á√ÉO DO SERIALIZER FALHANDO
   - M√©todo validate() pode estar lan√ßando exce√ß√£o n√£o capturada
   - Valida√ß√£o de autor_convidado pode ter bug com multipart data
   - Solu√ß√£o: Adicionar try-except no validate() com logging

3. MODEL SAVE() FALHANDO
   - Campos obrigat√≥rios do modelo n√£o est√£o sendo preenchidos
   - ForeignKey (categoria, cidade, estado) podem ter constraint errors
   - Solu√ß√£o: Verificar integridade referencial no banco

4. MIDDLEWARE OU PERMISS√ÉO BLOQUEANDO
   - AllowAny pode n√£o estar aplicado corretamente
   - CORS ou CSRF middleware podem estar rejeitando
   - Solu√ß√£o: Verificar settings.py e permission_classes

5. CLOUDINARY TIMEOUT NA REQUISI√á√ÉO HTTP REAL
   - Upload funciona em shell mas falha em produ√ß√£o
   - Gunicorn pode estar matando a requisi√ß√£o
   - Solu√ß√£o: Aumentar timeout do Gunicorn ou fazer upload ass√≠ncrono

6. PROBLEMA COM MULTIPART PARSER
   - Django pode n√£o estar parseando multipart/form-data corretamente
   - Boundary ou encoding podem estar incorretos
   - Solu√ß√£o: Verificar parser_classes no ViewSet

================================================================================
C√ìDIGO FLUTTER ESPERADO (EXEMPLO COM DIO)
================================================================================

import 'package:dio/dio.dart';

Future<void> criarDenuncia() async {
  final dio = Dio();
  
  // ADICIONAR LOGS ANTES DO UPLOAD
  print('üì§ Iniciando upload de den√∫ncia...');
  print('T√≠tulo: ${tituloController.text}');
  print('Categoria ID: $categoriaId');
  print('Autor convidado: ${autorConvidadoController.text}');
  print('Foto path: ${fotoFile.path}');
  print('Foto tamanho: ${await fotoFile.length()} bytes');
  
  FormData formData = FormData.fromMap({
    'titulo': tituloController.text.trim(),
    'descricao': descricaoController.text.trim(),
    'categoria': categoriaId.toString(), // Garantir string/int
    'latitude': latitude.toString(),
    'longitude': longitude.toString(),
    'autor_convidado': autorConvidadoController.text.trim(), // OBRIGAT√ìRIO!
    'foto': await MultipartFile.fromFile(
      fotoFile.path,
      filename: 'denuncia_${DateTime.now().millisecondsSinceEpoch}.jpg',
      contentType: MediaType('image', 'jpeg'), // Especificar tipo
    ),
  });
  
  try {
    print('üì° Enviando requisi√ß√£o...');
    final response = await dio.post(
      'https://72.61.55.172/api/denuncias/denuncias/',
      data: formData,
      options: Options(
        headers: {
          'Content-Type': 'multipart/form-data',
          // 'Authorization': 'Bearer $token', // Se autenticado
        },
        sendTimeout: Duration(seconds: 60), // Timeout maior
        receiveTimeout: Duration(seconds: 60),
      ),
    );
    
    print('‚úÖ Resposta: ${response.statusCode}');
    print('üì¶ Dados: ${response.data}');
    
  } catch (e) {
    print('‚ùå Erro: $e');
    if (e is DioException) {
      print('Status: ${e.response?.statusCode}');
      print('Data: ${e.response?.data}');
      print('Headers: ${e.response?.headers}');
    }
  }
}

================================================================================
DEBUGGING NO BACKEND DJANGO - CHECKLIST URGENTE
================================================================================

[‚úÖ] 1. FLUTTER EST√Å ENVIANDO TUDO CORRETO - Confirmado pelos logs
       - autor_convidado: "okok" ‚úÖ
       - Foto: 13.61 KB JPEG v√°lido ‚úÖ
       - Todos os campos presentes ‚úÖ

[‚ùå] 2. EXECUTAR TESTE DIAGN√ìSTICO NO VPS (URGENTE!)
       SSH: ssh root@72.61.55.172
       Container: docker exec -it voz-do-povo-api bash
       
       Executar no Django shell:
       
       python manage.py shell
       
       # Copiar e colar este c√≥digo:
       from django.test import RequestFactory
       from applications.denuncias.views import DenunciaViewSet
       from PIL import Image
       from io import BytesIO
       import traceback
       from django.contrib.auth.models import AnonymousUser
       
       factory = RequestFactory()
       img = Image.new('RGB', (100, 100), color='red')
       img_io = BytesIO()
       img.save(img_io, format='JPEG')
       img_io.seek(0)
       img_io.name = 'test.jpg'
       
       # Dados EXATAMENTE como Flutter envia
       post_data = {
           'titulo': 'dasfasf',
           'descricao': 'safasfasf',
           'categoria': '6',
           'cidade': '5275',
           'estado': '25',
           'latitude': '-23.549241',
           'longitude': '-46.631583',
           'jurisdicao': 'MUNICIPAL',
           'endereco': 'R. Venceslau Br√°s, Centro Hist√≥rico de S√£o Paulo - S√£o Paulo',
           'autor_convidado': 'okok',
           'foto': img_io
       }
       
       try:
           request = factory.post('/api/denuncias/denuncias/', data=post_data, format='multipart')
           request.user = AnonymousUser()
           
           view = DenunciaViewSet.as_view({'post': 'create'})
           response = view(request)
           
           print(f"Status: {response.status_code}")
           print(f"Data: {response.data}")
       except Exception as e:
           print(f"ERRO: {type(e).__name__}: {e}")
           traceback.print_exc()

[ ] 3. VERIFICAR SERIALIZER - applications/denuncias/serializers.py
       - Campos cidade, estado, jurisdicao, endereco est√£o declarados?
       - Meta.fields inclui todos os campos que Flutter envia?
       - H√° valida√ß√£o extra que pode estar falhando?

[ ] 4. VERIFICAR MODEL - applications/denuncias/models.py
       - Campos cidade, estado s√£o ForeignKey ou CharField?
       - Constraints de NOT NULL podem estar falhando?
       - Signal pre_save/post_save pode estar causando erro?

[ ] 5. ATIVAR DEBUG MODE REAL NO CONTAINER
       docker exec -it voz-do-povo-api bash
       echo "DEBUG=True" >> /app/.env
       docker restart voz-do-povo-api
       docker logs -f voz-do-povo-api
       
       Tentar criar den√∫ncia pelo Flutter novamente e ver traceback

[ ] 6. VERIFICAR GUNICORN TIMEOUT
       - Timeout atual: 300s
       - Upload Cloudinary pode estar demorando?
       - Solu√ß√£o: Verificar logs do Cloudinary API

[ ] 7. TESTAR COM CURL DIRETO NO VPS
       curl -X POST http://localhost:8000/api/denuncias/denuncias/ \
         -F "titulo=Teste Curl" \
         -F "descricao=Teste" \
         -F "categoria=6" \
         -F "cidade=5275" \
         -F "estado=25" \
         -F "latitude=-23.549241" \
         -F "longitude=-46.631583" \
         -F "jurisdicao=MUNICIPAL" \
         -F "endereco=Teste" \
         -F "autor_convidado=Curl Test" \
         -F "foto=@/tmp/test.jpg" \
         -v

[ ] 8. VERIFICAR LOGS DO GUNICORN EM TEMPO REAL
       docker logs -f voz-do-povo-api
       
       Procurar por:
       - Traceback do Python
       - ValidationError
       - IntegrityError
       - CloudinaryError

================================================================================
INFORMA√á√ïES DO AMBIENTE DE PRODU√á√ÉO
================================================================================

VPS: Hostinger srv1137163.hstgr.cloud
IP: 72.61.55.172
Container: voz-do-povo-api (Docker)
Backend: Django 5.2.8 + Gunicorn (3 workers, timeout 300s)
Database: Supabase PostgreSQL
Storage: Cloudinary CDN (cloud_name: dphpzghkh)
Python: 3.x
Django REST Framework: √öltima vers√£o

Cloudinary URL de teste (funcionando):
https://res.cloudinary.com/dphpzghkh/image/upload/v1/media/denuncias_fotos/test_real_bddtis

Storage Backend: MediaCloudinaryStorage (VERIFICADO)

================================================================================
PR√ìXIMOS PASSOS RECOMENDADOS (ATUALIZADO)
================================================================================

1. BACKEND DEVELOPER (URGENTE!) - Bruno Santos:
   ‚ö†Ô∏è O problema est√° NO BACKEND, n√£o no Flutter!
   
   a) EXECUTAR TESTE DIAGN√ìSTICO (c√≥digo acima no checklist item 2)
      - Vai revelar o erro exato que est√° acontecendo
      - Copiar o traceback completo
   
   b) ATIVAR DEBUG=True NO CONTAINER
      docker exec -it voz-do-povo-api bash -c "echo 'DEBUG=True' >> /app/.env"
      docker restart voz-do-povo-api
      - Reproduzir erro pelo Flutter
      - Coletar traceback dos logs
   
   c) VERIFICAR SERIALIZER
      - Checar se campos cidade, estado, jurisdicao, endereco existem
      - Verificar se Meta.fields = '__all__' ou lista expl√≠cita
      - Confirmar que autor_convidado est√° como write_only
   
   d) RECONSTRUIR CONTAINER COM LOGS
      docker compose down
      git pull
      docker compose build --no-cache
      docker compose up -d
      docker logs -f voz-do-povo-api

2. FLUTTER DEVELOPER:
   ‚úÖ Flutter est√° correto - NADA A FAZER por enquanto
   - Aguardar corre√ß√£o do backend
   - Logs j√° est√£o perfeitos para debugging

3. VALIDA√á√ÉO FINAL (Ap√≥s corre√ß√£o do backend):
   - Testar cria√ß√£o de den√∫ncia pelo Flutter
   - Verificar URL da foto no Cloudinary
   - Confirmar Status 201 Created
   - Validar dados salvos no banco

================================================================================
CONTATO E SUPORTE
================================================================================

Desenvolvedor Backend: Bruno Santos
Email: [seu_email@exemplo.com]
GitHub: https://github.com/eibrunoruan/VOZ-API

Documenta√ß√£o da API: [URL da documenta√ß√£o, se houver]
Swagger/OpenAPI: [URL do Swagger, se houver]

Para d√∫vidas ou assist√™ncia adicional, entre em contato via email ou GitHub.

================================================================================
FIM DO RELAT√ìRIO (ATUALIZADO 24/Nov/2025 - 01:30)
================================================================================

‚ö†Ô∏è RETIFICA√á√ÉO IMPORTANTE:

Ap√≥s an√°lise detalhada dos logs completos do Flutter, confirmamos que:

‚ùå DIAGN√ìSTICO ANTERIOR ESTAVA INCORRETO
‚úÖ Flutter est√° enviando TODOS os dados corretamente
‚úÖ autor_convidado presente ("okok")
‚úÖ Foto v√°lida (13.61 KB JPEG)
‚úÖ Todos os campos obrigat√≥rios presentes
‚úÖ ContentType e formato corretos

üéØ CONCLUS√ÉO CORRETA:
O problema est√° NO BACKEND DJANGO ao processar requisi√ß√µes HTTP multipart/form-data
reais vindas de clientes externos (n√£o simuladas via RequestFactory).

Os testes via Django Shell funcionaram porque s√£o simula√ß√µes internas, mas
requisi√ß√µes HTTP reais est√£o falhando. Isso indica problema no:
- Serializer (campos extras n√£o declarados: cidade, estado, jurisdicao, endereco)
- Parser de multipart data
- Middleware ou permiss√µes
- Upload Cloudinary em requisi√ß√µes HTTP reais

üîß A√á√ÉO NECESS√ÅRIA:
Backend developer deve executar o teste diagn√≥stico fornecido no checklist
e ativar DEBUG=True para capturar o traceback completo do erro 500.

Este erro √© um 500 Internal Server Error do Django, N√ÉO um erro do cliente.
